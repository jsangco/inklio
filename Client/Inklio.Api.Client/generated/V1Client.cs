// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Inklio.Api.Client
{
    // Data plane generated client.
    /// <summary> The V1 service client. </summary>
    public partial class V1Client
    {
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of V1Client. </summary>
        public V1Client() : this(new Uri(""), new InklioApiClientOptions())
        {
        }

        /// <summary> Initializes a new instance of V1Client. </summary>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> is null. </exception>
        public V1Client(Uri endpoint, InklioApiClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new InklioApiClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), Array.Empty<HttpPipelinePolicy>(), new ResponseClassifier());
            _endpoint = endpoint;
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsAdminsGETAsync(RequestContext)']/*" />
        public virtual async Task<Response> AccountsAdminsGETAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsAdminsGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsAdminsGETRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsAdminsGET(RequestContext)']/*" />
        public virtual Response AccountsAdminsGET(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsAdminsGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsAdminsGETRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsClaimsGETAsync(RequestContext)']/*" />
        public virtual async Task<Response> AccountsClaimsGETAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsClaimsGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsClaimsGETRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsClaimsGET(RequestContext)']/*" />
        public virtual Response AccountsClaimsGET(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsClaimsGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsClaimsGETRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsLoginPostAsync(RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> AccountsLoginPostAsync(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsLoginPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsLoginPostRequest(content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsLoginPost(RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response AccountsLoginPost(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsLoginPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsLoginPostRequest(content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsLogoutPostAsync(RequestContext)']/*" />
        public virtual async Task<Response> AccountsLogoutPostAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsLogoutPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsLogoutPostRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsLogoutPost(RequestContext)']/*" />
        public virtual Response AccountsLogoutPost(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsLogoutPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsLogoutPostRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsRegisterPostAsync(RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> AccountsRegisterPostAsync(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsRegisterPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsRegisterPostRequest(content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsRegisterPost(RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response AccountsRegisterPost(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsRegisterPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsRegisterPostRequest(content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsForgetPostAsync(RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> AccountsForgetPostAsync(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsForgetPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsForgetPostRequest(content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsForgetPost(RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response AccountsForgetPost(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsForgetPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsForgetPostRequest(content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsResetPostAsync(RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> AccountsResetPostAsync(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsResetPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsResetPostRequest(content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AccountsResetPost(RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response AccountsResetPost(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AccountsResetPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAccountsResetPostRequest(content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksGETAsync(RequestContext)']/*" />
        public virtual async Task<Response> AsksGETAsync(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksGETRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksGET(RequestContext)']/*" />
        public virtual Response AsksGET(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksGETRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksPostAsync(RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> AsksPostAsync(RequestContent content, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksPostRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksPost(RequestContent,RequestContext)']/*" />
        public virtual Response AsksPost(RequestContent content, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksPostRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksCountGETAsync(RequestContext)']/*" />
        public virtual async Task<Response> AsksCountGETAsync(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksCountGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksCountGETRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksCountGET(RequestContext)']/*" />
        public virtual Response AsksCountGET(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksCountGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksCountGETRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdGETAsync(int,RequestContext)']/*" />
        public virtual async Task<Response> AsksAskIdGETAsync(int askId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdGETRequest(askId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdGET(int,RequestContext)']/*" />
        public virtual Response AsksAskIdGET(int askId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdGETRequest(askId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdCommentsGETAsync(int,RequestContext)']/*" />
        public virtual async Task<Response> AsksAskIdCommentsGETAsync(int askId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdCommentsGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdCommentsGETRequest(askId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdCommentsGET(int,RequestContext)']/*" />
        public virtual Response AsksAskIdCommentsGET(int askId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdCommentsGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdCommentsGETRequest(askId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdCommentsPostAsync(int,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> AsksAskIdCommentsPostAsync(int askId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdCommentsPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdCommentsPostRequest(askId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdCommentsPost(int,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response AsksAskIdCommentsPost(int askId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdCommentsPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdCommentsPostRequest(askId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesGETAsync(int,RequestContext)']/*" />
        public virtual async Task<Response> AsksAskIdDeliveriesGETAsync(int askId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesGETRequest(askId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesGET(int,RequestContext)']/*" />
        public virtual Response AsksAskIdDeliveriesGET(int askId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesGETRequest(askId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesPostAsync(int,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> AsksAskIdDeliveriesPostAsync(int askId, RequestContent content, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesPostRequest(askId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesPost(int,RequestContent,RequestContext)']/*" />
        public virtual Response AsksAskIdDeliveriesPost(int askId, RequestContent content, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesPostRequest(askId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="deliveryId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesDeliveryIdGETAsync(int,int,RequestContext)']/*" />
        public virtual async Task<Response> AsksAskIdDeliveriesDeliveryIdGETAsync(int askId, int deliveryId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesDeliveryIdGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesDeliveryIdGETRequest(askId, deliveryId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="deliveryId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesDeliveryIdGET(int,int,RequestContext)']/*" />
        public virtual Response AsksAskIdDeliveriesDeliveryIdGET(int askId, int deliveryId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesDeliveryIdGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesDeliveryIdGETRequest(askId, deliveryId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="deliveryId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesDeliveryIdCommentsGETAsync(int,int,RequestContext)']/*" />
        public virtual async Task<Response> AsksAskIdDeliveriesDeliveryIdCommentsGETAsync(int askId, int deliveryId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesDeliveryIdCommentsGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesDeliveryIdCommentsGETRequest(askId, deliveryId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="deliveryId"> The Int32 to use. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesDeliveryIdCommentsGET(int,int,RequestContext)']/*" />
        public virtual Response AsksAskIdDeliveriesDeliveryIdCommentsGET(int askId, int deliveryId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesDeliveryIdCommentsGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesDeliveryIdCommentsGETRequest(askId, deliveryId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="deliveryId"> The Int32 to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesDeliveryIdCommentsPostAsync(int,int,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> AsksAskIdDeliveriesDeliveryIdCommentsPostAsync(int askId, int deliveryId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesDeliveryIdCommentsPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesDeliveryIdCommentsPostRequest(askId, deliveryId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="deliveryId"> The Int32 to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesDeliveryIdCommentsPost(int,int,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response AsksAskIdDeliveriesDeliveryIdCommentsPost(int askId, int deliveryId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesDeliveryIdCommentsPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesDeliveryIdCommentsPostRequest(askId, deliveryId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdTagsPostAsync(int,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> AsksAskIdTagsPostAsync(int askId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdTagsPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdTagsPostRequest(askId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdTagsPost(int,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response AsksAskIdTagsPost(int askId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdTagsPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdTagsPostRequest(askId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="deliveryId"> The Int32 to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesDeliveryIdTagsPostAsync(int,int,RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> AsksAskIdDeliveriesDeliveryIdTagsPostAsync(int askId, int deliveryId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesDeliveryIdTagsPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesDeliveryIdTagsPostRequest(askId, deliveryId, content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="askId"> The Int32 to use. </param>
        /// <param name="deliveryId"> The Int32 to use. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='AsksAskIdDeliveriesDeliveryIdTagsPost(int,int,RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response AsksAskIdDeliveriesDeliveryIdTagsPost(int askId, int deliveryId, RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.AsksAskIdDeliveriesDeliveryIdTagsPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAsksAskIdDeliveriesDeliveryIdTagsPostRequest(askId, deliveryId, content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='MetadataGETAsync(RequestContext)']/*" />
        public virtual async Task<Response> MetadataGETAsync(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.MetadataGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateMetadataGETRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='MetadataGET(RequestContext)']/*" />
        public virtual Response MetadataGET(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.MetadataGET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateMetadataGETRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='GETAsync(RequestContext)']/*" />
        public virtual async Task<Response> GETAsync(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.GET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGETRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='GET(RequestContext)']/*" />
        public virtual Response GET(RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.GET");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGETRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='TestPostAsync(RequestContent,ContentType,RequestContext)']/*" />
        public virtual async Task<Response> TestPostAsync(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.TestPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTestPostRequest(content, contentType, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method]
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="contentType"> Body Parameter content-type. Allowed values: "application/*+json" | "application/json" | "application/json;odata.metadata=full" | "application/json;odata.metadata=full;odata.streaming=false" | "application/json;odata.metadata=full;odata.streaming=true" | "application/json;odata.metadata=minimal" | "application/json;odata.metadata=minimal;odata.streaming=false" | "application/json;odata.metadata=minimal;odata.streaming=true" | "application/json;odata.metadata=none" | "application/json;odata.metadata=none;odata.streaming=false" | "application/json;odata.metadata=none;odata.streaming=true" | "application/json;odata.streaming=false" | "application/json;odata.streaming=true" | "application/xml" | "text/json" | "text/plain". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/V1Client.xml" path="doc/members/member[@name='TestPost(RequestContent,ContentType,RequestContext)']/*" />
        public virtual Response TestPost(RequestContent content, ContentType contentType, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("V1Client.TestPost");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTestPostRequest(content, contentType, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateAccountsAdminsGETRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/accounts/admins", false);
            request.Uri = uri;
            return message;
        }

        internal HttpMessage CreateAccountsClaimsGETRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/accounts/claims", false);
            request.Uri = uri;
            return message;
        }

        internal HttpMessage CreateAccountsLoginPostRequest(RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/accounts/login", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAccountsLogoutPostRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/accounts/logout", false);
            request.Uri = uri;
            return message;
        }

        internal HttpMessage CreateAccountsRegisterPostRequest(RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/accounts/register", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAccountsForgetPostRequest(RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/accounts/forget", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAccountsResetPostRequest(RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/accounts/reset", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAsksGETRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json;odata.metadata=minimal;odata.streaming=true, application/json;odata.metadata=minimal;odata.streaming=false, application/json;odata.metadata=minimal, application/json;odata.metadata=full;odata.streaming=true, application/json;odata.metadata=full;odata.streaming=false, application/json;odata.metadata=full, application/json;odata.metadata=none;odata.streaming=true, application/json;odata.metadata=none;odata.streaming=false, application/json;odata.metadata=none, application/json;odata.streaming=true, application/json;odata.streaming=false, application/json, text/json, application/xml");
            return message;
        }

        internal HttpMessage CreateAsksPostRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAsksCountGETRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/$count", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json;odata.metadata=minimal;odata.streaming=true, application/json;odata.metadata=minimal;odata.streaming=false, application/json;odata.metadata=minimal, application/json;odata.metadata=full;odata.streaming=true, application/json;odata.metadata=full;odata.streaming=false, application/json;odata.metadata=full, application/json;odata.metadata=none;odata.streaming=true, application/json;odata.metadata=none;odata.streaming=false, application/json;odata.metadata=none, application/json;odata.streaming=true, application/json;odata.streaming=false, application/json, text/json, application/xml");
            return message;
        }

        internal HttpMessage CreateAsksAskIdGETRequest(int askId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/", false);
            uri.AppendPath(askId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json;odata.metadata=minimal;odata.streaming=true, application/json;odata.metadata=minimal;odata.streaming=false, application/json;odata.metadata=minimal, application/json;odata.metadata=full;odata.streaming=true, application/json;odata.metadata=full;odata.streaming=false, application/json;odata.metadata=full, application/json;odata.metadata=none;odata.streaming=true, application/json;odata.metadata=none;odata.streaming=false, application/json;odata.metadata=none, application/json;odata.streaming=true, application/json;odata.streaming=false, application/json, text/json, application/xml");
            return message;
        }

        internal HttpMessage CreateAsksAskIdCommentsGETRequest(int askId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/", false);
            uri.AppendPath(askId, true);
            uri.AppendPath("/comments", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json;odata.metadata=minimal;odata.streaming=true, application/json;odata.metadata=minimal;odata.streaming=false, application/json;odata.metadata=minimal, application/json;odata.metadata=full;odata.streaming=true, application/json;odata.metadata=full;odata.streaming=false, application/json;odata.metadata=full, application/json;odata.metadata=none;odata.streaming=true, application/json;odata.metadata=none;odata.streaming=false, application/json;odata.metadata=none, application/json;odata.streaming=true, application/json;odata.streaming=false, application/json, text/json, application/xml");
            return message;
        }

        internal HttpMessage CreateAsksAskIdCommentsPostRequest(int askId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/", false);
            uri.AppendPath(askId, true);
            uri.AppendPath("/comments", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAsksAskIdDeliveriesGETRequest(int askId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/", false);
            uri.AppendPath(askId, true);
            uri.AppendPath("/deliveries", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json;odata.metadata=minimal;odata.streaming=true, application/json;odata.metadata=minimal;odata.streaming=false, application/json;odata.metadata=minimal, application/json;odata.metadata=full;odata.streaming=true, application/json;odata.metadata=full;odata.streaming=false, application/json;odata.metadata=full, application/json;odata.metadata=none;odata.streaming=true, application/json;odata.metadata=none;odata.streaming=false, application/json;odata.metadata=none, application/json;odata.streaming=true, application/json;odata.streaming=false, application/json, text/json, application/xml");
            return message;
        }

        internal HttpMessage CreateAsksAskIdDeliveriesPostRequest(int askId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/", false);
            uri.AppendPath(askId, true);
            uri.AppendPath("/deliveries", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", "multipart/form-data");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAsksAskIdDeliveriesDeliveryIdGETRequest(int askId, int deliveryId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/", false);
            uri.AppendPath(askId, true);
            uri.AppendPath("/deliveries/", false);
            uri.AppendPath(deliveryId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json;odata.metadata=minimal;odata.streaming=true, application/json;odata.metadata=minimal;odata.streaming=false, application/json;odata.metadata=minimal, application/json;odata.metadata=full;odata.streaming=true, application/json;odata.metadata=full;odata.streaming=false, application/json;odata.metadata=full, application/json;odata.metadata=none;odata.streaming=true, application/json;odata.metadata=none;odata.streaming=false, application/json;odata.metadata=none, application/json;odata.streaming=true, application/json;odata.streaming=false, application/json, text/json, application/xml");
            return message;
        }

        internal HttpMessage CreateAsksAskIdDeliveriesDeliveryIdCommentsGETRequest(int askId, int deliveryId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/", false);
            uri.AppendPath(askId, true);
            uri.AppendPath("/deliveries/", false);
            uri.AppendPath(deliveryId, true);
            uri.AppendPath("/comments", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json;odata.metadata=minimal;odata.streaming=true, application/json;odata.metadata=minimal;odata.streaming=false, application/json;odata.metadata=minimal, application/json;odata.metadata=full;odata.streaming=true, application/json;odata.metadata=full;odata.streaming=false, application/json;odata.metadata=full, application/json;odata.metadata=none;odata.streaming=true, application/json;odata.metadata=none;odata.streaming=false, application/json;odata.metadata=none, application/json;odata.streaming=true, application/json;odata.streaming=false, application/json, text/json, application/xml");
            return message;
        }

        internal HttpMessage CreateAsksAskIdDeliveriesDeliveryIdCommentsPostRequest(int askId, int deliveryId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/", false);
            uri.AppendPath(askId, true);
            uri.AppendPath("/deliveries/", false);
            uri.AppendPath(deliveryId, true);
            uri.AppendPath("/comments", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAsksAskIdTagsPostRequest(int askId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/", false);
            uri.AppendPath(askId, true);
            uri.AppendPath("/tags", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAsksAskIdDeliveriesDeliveryIdTagsPostRequest(int askId, int deliveryId, RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/asks/", false);
            uri.AppendPath(askId, true);
            uri.AppendPath("/deliveries/", false);
            uri.AppendPath(deliveryId, true);
            uri.AppendPath("/tags", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateMetadataGETRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/$metadata", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json;odata.metadata=minimal;odata.streaming=true, application/json;odata.metadata=minimal;odata.streaming=false, application/json;odata.metadata=minimal, application/json;odata.metadata=full;odata.streaming=true, application/json;odata.metadata=full;odata.streaming=false, application/json;odata.metadata=full, application/json;odata.metadata=none;odata.streaming=true, application/json;odata.metadata=none;odata.streaming=false, application/json;odata.metadata=none, application/json;odata.streaming=true, application/json;odata.streaming=false, application/json, text/json, application/xml");
            return message;
        }

        internal HttpMessage CreateGETRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json;odata.metadata=minimal;odata.streaming=true, application/json;odata.metadata=minimal;odata.streaming=false, application/json;odata.metadata=minimal, application/json;odata.metadata=full;odata.streaming=true, application/json;odata.metadata=full;odata.streaming=false, application/json;odata.metadata=full, application/json;odata.metadata=none;odata.streaming=true, application/json;odata.metadata=none;odata.streaming=false, application/json;odata.metadata=none, application/json;odata.streaming=true, application/json;odata.streaming=false, application/json, text/json, application/xml");
            return message;
        }

        internal HttpMessage CreateTestPostRequest(RequestContent content, ContentType contentType, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/v1/test", false);
            request.Uri = uri;
            request.Headers.Add("Content-Type", contentType.ToString());
            request.Content = content;
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
